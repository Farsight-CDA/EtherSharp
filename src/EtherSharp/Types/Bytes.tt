<#@ template language="C#" #><#
#><#@ output extension=".generated.cs" #><#= "// <auto-generated/>" #><#
#>using EtherSharp.Common;
using EtherSharp.Common.Converter;
using System.Buffers;
using System.Buffers.Binary;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text.Json.Serialization;

namespace EtherSharp.Types;

public interface IFixedBytes<TSelf>
    where TSelf : struct, IFixedBytes<TSelf>
{
    static abstract int BYTE_LENGTH { get; }

    ReadOnlySpan<byte> Bytes { get; }

    static abstract TSelf FromBytes(ReadOnlySpan<byte> bytes);
}

<#
for(var i = 1; i <= 32; i++)
{
#>
<#= i == 32 ? "[JsonConverter(typeof(Bytes32Converter))]" : "" #>
public struct Bytes<#= i #> : IEquatable<Bytes<#= i #>>, IComparable<Bytes<#= i #>>, IFixedBytes<Bytes<#= i #>>
{
    public const int BYTE_LENGTH = <#= i #>;

    public const int STRING_LENGTH = <#= (i * 2) + 2 #>;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage<#= i #>
    {
        private byte _element0;
    }

    private ByteStorage<#= i #> _bytes;

    public static Bytes<#= i #> Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes<#= i #>>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes<#= i #> Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes<#= i #> Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a <#= i #>-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes<#= i #> parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes<#= i #> parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes<#= i #> FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes<#= i #> requires exactly <#= i #> bytes", nameof(bytes));
        }

        var result = default(Bytes<#= i #>);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes<#= i #> other)
        => <#
            int full = i // 8
            int rem = i % 8
            if full == 0 and rem == 1:
#>LoadU8Raw(0) == other.LoadU8Raw(0)<#
            else:
                terms=[]
                for off in range(0, full*8, 8):
                    terms.append(f"(LoadU64Raw({off}) ^ other.LoadU64Raw({off}))")
                for off in range(full*8, full*8+rem):
                    terms.append(f"(LoadU8Raw({off}) ^ other.LoadU8Raw({off}))")
                if not terms:
                    terms=['0']
#>((<#= "\n            | ".join(terms) #>)) == 0<#
#>;

    public bool Equals(Bytes<#= i #> other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes<#= i #> other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
<##>
<#
for off in range(0, (i//8)*8, 8):
#>        hash.Add(LoadU64BE(<#= off #>));
<#
for off in range((i//8)*8, i):
#>        hash.Add(LoadU8Raw(<#= off #>));
<#
#>        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes<#= i #> other)
    {
<#
for off in range(0, (i//8)*8, 8):
#>        int cmp<#= off #> = LoadU64BE(<#= off #>).CompareTo(other.LoadU64BE(<#= off #>));
        if(cmp<#= off #> != 0)
        {
            return cmp<#= off #>;
        }

<#
for off in range((i//8)*8, i):
#>        int byteCmp<#= off #> = LoadU8Raw(<#= off #>).CompareTo(other.LoadU8Raw(<#= off #>));
        if(byteCmp<#= off #> != 0)
        {
            return byteCmp<#= off #>;
        }

<#
#>        return 0;
    }

    public int CompareTo(Bytes<#= i #> other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes<#= i #> left, in Bytes<#= i #> right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes<#= i #> left, in Bytes<#= i #> right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

<#
}
#>
