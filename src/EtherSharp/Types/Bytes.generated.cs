// <auto-generated/>
#nullable enable
#pragma warning disable CS1591, CS0675
using EtherSharp.Common;
using EtherSharp.Common.Converter;
using System.Buffers;
using System.Buffers.Binary;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text.Json.Serialization;

namespace EtherSharp.Types;

public interface IFixedBytes<TSelf>
    where TSelf : struct, IFixedBytes<TSelf>
{
    static abstract int BYTE_LENGTH { get; }

    ReadOnlySpan<byte> Bytes { get; }

    static abstract TSelf FromBytes(ReadOnlySpan<byte> bytes);
}

public struct Bytes1 : IEquatable<Bytes1>, IComparable<Bytes1>, IFixedBytes<Bytes1>
{
    public const int BYTE_LENGTH = 1;

    public const int STRING_LENGTH = 4;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage1
    {
        private byte _element0;
    }

    private ByteStorage1 _bytes;

    public static Bytes1 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes1>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes1 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes1 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 1-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes1 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes1 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes1 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes1 requires exactly 1 bytes", nameof(bytes));
        }

        var result = default(Bytes1);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes1 other)
        => LoadU8Raw(0) == other.LoadU8Raw(0);

    public bool Equals(Bytes1 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes1 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU8Raw(0));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes1 other)
    {
        int byteCmp0 = LoadU8Raw(0).CompareTo(other.LoadU8Raw(0));
        if(byteCmp0 != 0)
        {
            return byteCmp0;
        }

        return 0;
    }

    public int CompareTo(Bytes1 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes1 left, in Bytes1 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes1 left, in Bytes1 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes2 : IEquatable<Bytes2>, IComparable<Bytes2>, IFixedBytes<Bytes2>
{
    public const int BYTE_LENGTH = 2;

    public const int STRING_LENGTH = 6;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage2
    {
        private byte _element0;
    }

    private ByteStorage2 _bytes;

    public static Bytes2 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes2>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes2 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes2 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 2-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes2 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes2 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes2 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes2 requires exactly 2 bytes", nameof(bytes));
        }

        var result = default(Bytes2);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes2 other)
        => ((
            ((ulong) (LoadU8Raw(0) ^ other.LoadU8Raw(0)))
            | ((ulong) (LoadU8Raw(1) ^ other.LoadU8Raw(1)))
        )) == 0;

    public bool Equals(Bytes2 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes2 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU8Raw(0));
        hash.Add(LoadU8Raw(1));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes2 other)
    {
        int byteCmp0 = LoadU8Raw(0).CompareTo(other.LoadU8Raw(0));
        if(byteCmp0 != 0)
        {
            return byteCmp0;
        }

        int byteCmp1 = LoadU8Raw(1).CompareTo(other.LoadU8Raw(1));
        if(byteCmp1 != 0)
        {
            return byteCmp1;
        }

        return 0;
    }

    public int CompareTo(Bytes2 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes2 left, in Bytes2 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes2 left, in Bytes2 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes3 : IEquatable<Bytes3>, IComparable<Bytes3>, IFixedBytes<Bytes3>
{
    public const int BYTE_LENGTH = 3;

    public const int STRING_LENGTH = 8;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage3
    {
        private byte _element0;
    }

    private ByteStorage3 _bytes;

    public static Bytes3 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes3>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes3 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes3 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 3-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes3 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes3 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes3 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes3 requires exactly 3 bytes", nameof(bytes));
        }

        var result = default(Bytes3);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes3 other)
        => ((
            ((ulong) (LoadU8Raw(0) ^ other.LoadU8Raw(0)))
            | ((ulong) (LoadU8Raw(1) ^ other.LoadU8Raw(1)))
            | ((ulong) (LoadU8Raw(2) ^ other.LoadU8Raw(2)))
        )) == 0;

    public bool Equals(Bytes3 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes3 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU8Raw(0));
        hash.Add(LoadU8Raw(1));
        hash.Add(LoadU8Raw(2));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes3 other)
    {
        int byteCmp0 = LoadU8Raw(0).CompareTo(other.LoadU8Raw(0));
        if(byteCmp0 != 0)
        {
            return byteCmp0;
        }

        int byteCmp1 = LoadU8Raw(1).CompareTo(other.LoadU8Raw(1));
        if(byteCmp1 != 0)
        {
            return byteCmp1;
        }

        int byteCmp2 = LoadU8Raw(2).CompareTo(other.LoadU8Raw(2));
        if(byteCmp2 != 0)
        {
            return byteCmp2;
        }

        return 0;
    }

    public int CompareTo(Bytes3 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes3 left, in Bytes3 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes3 left, in Bytes3 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes4 : IEquatable<Bytes4>, IComparable<Bytes4>, IFixedBytes<Bytes4>
{
    public const int BYTE_LENGTH = 4;

    public const int STRING_LENGTH = 10;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage4
    {
        private byte _element0;
    }

    private ByteStorage4 _bytes;

    public static Bytes4 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes4>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes4 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes4 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 4-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes4 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes4 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes4 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes4 requires exactly 4 bytes", nameof(bytes));
        }

        var result = default(Bytes4);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes4 other)
        => ((
            ((ulong) (LoadU8Raw(0) ^ other.LoadU8Raw(0)))
            | ((ulong) (LoadU8Raw(1) ^ other.LoadU8Raw(1)))
            | ((ulong) (LoadU8Raw(2) ^ other.LoadU8Raw(2)))
            | ((ulong) (LoadU8Raw(3) ^ other.LoadU8Raw(3)))
        )) == 0;

    public bool Equals(Bytes4 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes4 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU8Raw(0));
        hash.Add(LoadU8Raw(1));
        hash.Add(LoadU8Raw(2));
        hash.Add(LoadU8Raw(3));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes4 other)
    {
        int byteCmp0 = LoadU8Raw(0).CompareTo(other.LoadU8Raw(0));
        if(byteCmp0 != 0)
        {
            return byteCmp0;
        }

        int byteCmp1 = LoadU8Raw(1).CompareTo(other.LoadU8Raw(1));
        if(byteCmp1 != 0)
        {
            return byteCmp1;
        }

        int byteCmp2 = LoadU8Raw(2).CompareTo(other.LoadU8Raw(2));
        if(byteCmp2 != 0)
        {
            return byteCmp2;
        }

        int byteCmp3 = LoadU8Raw(3).CompareTo(other.LoadU8Raw(3));
        if(byteCmp3 != 0)
        {
            return byteCmp3;
        }

        return 0;
    }

    public int CompareTo(Bytes4 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes4 left, in Bytes4 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes4 left, in Bytes4 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes5 : IEquatable<Bytes5>, IComparable<Bytes5>, IFixedBytes<Bytes5>
{
    public const int BYTE_LENGTH = 5;

    public const int STRING_LENGTH = 12;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage5
    {
        private byte _element0;
    }

    private ByteStorage5 _bytes;

    public static Bytes5 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes5>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes5 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes5 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 5-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes5 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes5 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes5 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes5 requires exactly 5 bytes", nameof(bytes));
        }

        var result = default(Bytes5);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes5 other)
        => ((
            ((ulong) (LoadU8Raw(0) ^ other.LoadU8Raw(0)))
            | ((ulong) (LoadU8Raw(1) ^ other.LoadU8Raw(1)))
            | ((ulong) (LoadU8Raw(2) ^ other.LoadU8Raw(2)))
            | ((ulong) (LoadU8Raw(3) ^ other.LoadU8Raw(3)))
            | ((ulong) (LoadU8Raw(4) ^ other.LoadU8Raw(4)))
        )) == 0;

    public bool Equals(Bytes5 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes5 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU8Raw(0));
        hash.Add(LoadU8Raw(1));
        hash.Add(LoadU8Raw(2));
        hash.Add(LoadU8Raw(3));
        hash.Add(LoadU8Raw(4));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes5 other)
    {
        int byteCmp0 = LoadU8Raw(0).CompareTo(other.LoadU8Raw(0));
        if(byteCmp0 != 0)
        {
            return byteCmp0;
        }

        int byteCmp1 = LoadU8Raw(1).CompareTo(other.LoadU8Raw(1));
        if(byteCmp1 != 0)
        {
            return byteCmp1;
        }

        int byteCmp2 = LoadU8Raw(2).CompareTo(other.LoadU8Raw(2));
        if(byteCmp2 != 0)
        {
            return byteCmp2;
        }

        int byteCmp3 = LoadU8Raw(3).CompareTo(other.LoadU8Raw(3));
        if(byteCmp3 != 0)
        {
            return byteCmp3;
        }

        int byteCmp4 = LoadU8Raw(4).CompareTo(other.LoadU8Raw(4));
        if(byteCmp4 != 0)
        {
            return byteCmp4;
        }

        return 0;
    }

    public int CompareTo(Bytes5 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes5 left, in Bytes5 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes5 left, in Bytes5 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes6 : IEquatable<Bytes6>, IComparable<Bytes6>, IFixedBytes<Bytes6>
{
    public const int BYTE_LENGTH = 6;

    public const int STRING_LENGTH = 14;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage6
    {
        private byte _element0;
    }

    private ByteStorage6 _bytes;

    public static Bytes6 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes6>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes6 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes6 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 6-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes6 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes6 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes6 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes6 requires exactly 6 bytes", nameof(bytes));
        }

        var result = default(Bytes6);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes6 other)
        => ((
            ((ulong) (LoadU8Raw(0) ^ other.LoadU8Raw(0)))
            | ((ulong) (LoadU8Raw(1) ^ other.LoadU8Raw(1)))
            | ((ulong) (LoadU8Raw(2) ^ other.LoadU8Raw(2)))
            | ((ulong) (LoadU8Raw(3) ^ other.LoadU8Raw(3)))
            | ((ulong) (LoadU8Raw(4) ^ other.LoadU8Raw(4)))
            | ((ulong) (LoadU8Raw(5) ^ other.LoadU8Raw(5)))
        )) == 0;

    public bool Equals(Bytes6 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes6 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU8Raw(0));
        hash.Add(LoadU8Raw(1));
        hash.Add(LoadU8Raw(2));
        hash.Add(LoadU8Raw(3));
        hash.Add(LoadU8Raw(4));
        hash.Add(LoadU8Raw(5));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes6 other)
    {
        int byteCmp0 = LoadU8Raw(0).CompareTo(other.LoadU8Raw(0));
        if(byteCmp0 != 0)
        {
            return byteCmp0;
        }

        int byteCmp1 = LoadU8Raw(1).CompareTo(other.LoadU8Raw(1));
        if(byteCmp1 != 0)
        {
            return byteCmp1;
        }

        int byteCmp2 = LoadU8Raw(2).CompareTo(other.LoadU8Raw(2));
        if(byteCmp2 != 0)
        {
            return byteCmp2;
        }

        int byteCmp3 = LoadU8Raw(3).CompareTo(other.LoadU8Raw(3));
        if(byteCmp3 != 0)
        {
            return byteCmp3;
        }

        int byteCmp4 = LoadU8Raw(4).CompareTo(other.LoadU8Raw(4));
        if(byteCmp4 != 0)
        {
            return byteCmp4;
        }

        int byteCmp5 = LoadU8Raw(5).CompareTo(other.LoadU8Raw(5));
        if(byteCmp5 != 0)
        {
            return byteCmp5;
        }

        return 0;
    }

    public int CompareTo(Bytes6 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes6 left, in Bytes6 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes6 left, in Bytes6 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes7 : IEquatable<Bytes7>, IComparable<Bytes7>, IFixedBytes<Bytes7>
{
    public const int BYTE_LENGTH = 7;

    public const int STRING_LENGTH = 16;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage7
    {
        private byte _element0;
    }

    private ByteStorage7 _bytes;

    public static Bytes7 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes7>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes7 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes7 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 7-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes7 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes7 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes7 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes7 requires exactly 7 bytes", nameof(bytes));
        }

        var result = default(Bytes7);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes7 other)
        => ((
            ((ulong) (LoadU8Raw(0) ^ other.LoadU8Raw(0)))
            | ((ulong) (LoadU8Raw(1) ^ other.LoadU8Raw(1)))
            | ((ulong) (LoadU8Raw(2) ^ other.LoadU8Raw(2)))
            | ((ulong) (LoadU8Raw(3) ^ other.LoadU8Raw(3)))
            | ((ulong) (LoadU8Raw(4) ^ other.LoadU8Raw(4)))
            | ((ulong) (LoadU8Raw(5) ^ other.LoadU8Raw(5)))
            | ((ulong) (LoadU8Raw(6) ^ other.LoadU8Raw(6)))
        )) == 0;

    public bool Equals(Bytes7 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes7 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU8Raw(0));
        hash.Add(LoadU8Raw(1));
        hash.Add(LoadU8Raw(2));
        hash.Add(LoadU8Raw(3));
        hash.Add(LoadU8Raw(4));
        hash.Add(LoadU8Raw(5));
        hash.Add(LoadU8Raw(6));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes7 other)
    {
        int byteCmp0 = LoadU8Raw(0).CompareTo(other.LoadU8Raw(0));
        if(byteCmp0 != 0)
        {
            return byteCmp0;
        }

        int byteCmp1 = LoadU8Raw(1).CompareTo(other.LoadU8Raw(1));
        if(byteCmp1 != 0)
        {
            return byteCmp1;
        }

        int byteCmp2 = LoadU8Raw(2).CompareTo(other.LoadU8Raw(2));
        if(byteCmp2 != 0)
        {
            return byteCmp2;
        }

        int byteCmp3 = LoadU8Raw(3).CompareTo(other.LoadU8Raw(3));
        if(byteCmp3 != 0)
        {
            return byteCmp3;
        }

        int byteCmp4 = LoadU8Raw(4).CompareTo(other.LoadU8Raw(4));
        if(byteCmp4 != 0)
        {
            return byteCmp4;
        }

        int byteCmp5 = LoadU8Raw(5).CompareTo(other.LoadU8Raw(5));
        if(byteCmp5 != 0)
        {
            return byteCmp5;
        }

        int byteCmp6 = LoadU8Raw(6).CompareTo(other.LoadU8Raw(6));
        if(byteCmp6 != 0)
        {
            return byteCmp6;
        }

        return 0;
    }

    public int CompareTo(Bytes7 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes7 left, in Bytes7 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes7 left, in Bytes7 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes8 : IEquatable<Bytes8>, IComparable<Bytes8>, IFixedBytes<Bytes8>
{
    public const int BYTE_LENGTH = 8;

    public const int STRING_LENGTH = 18;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage8
    {
        private byte _element0;
    }

    private ByteStorage8 _bytes;

    public static Bytes8 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes8>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes8 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes8 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 8-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes8 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes8 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes8 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes8 requires exactly 8 bytes", nameof(bytes));
        }

        var result = default(Bytes8);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes8 other)
        => ((
            (LoadU64Raw(0) ^ other.LoadU64Raw(0))
        )) == 0;

    public bool Equals(Bytes8 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes8 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU64BE(0));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes8 other)
    {
        int cmp0 = LoadU64BE(0).CompareTo(other.LoadU64BE(0));
        if(cmp0 != 0)
        {
            return cmp0;
        }

        return 0;
    }

    public int CompareTo(Bytes8 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes8 left, in Bytes8 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes8 left, in Bytes8 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes9 : IEquatable<Bytes9>, IComparable<Bytes9>, IFixedBytes<Bytes9>
{
    public const int BYTE_LENGTH = 9;

    public const int STRING_LENGTH = 20;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage9
    {
        private byte _element0;
    }

    private ByteStorage9 _bytes;

    public static Bytes9 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes9>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes9 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes9 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 9-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes9 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes9 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes9 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes9 requires exactly 9 bytes", nameof(bytes));
        }

        var result = default(Bytes9);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes9 other)
        => ((
            (LoadU64Raw(0) ^ other.LoadU64Raw(0))
            | ((ulong) (LoadU8Raw(8) ^ other.LoadU8Raw(8)))
        )) == 0;

    public bool Equals(Bytes9 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes9 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU64BE(0));
        hash.Add(LoadU8Raw(8));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes9 other)
    {
        int cmp0 = LoadU64BE(0).CompareTo(other.LoadU64BE(0));
        if(cmp0 != 0)
        {
            return cmp0;
        }

        int byteCmp8 = LoadU8Raw(8).CompareTo(other.LoadU8Raw(8));
        if(byteCmp8 != 0)
        {
            return byteCmp8;
        }

        return 0;
    }

    public int CompareTo(Bytes9 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes9 left, in Bytes9 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes9 left, in Bytes9 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes10 : IEquatable<Bytes10>, IComparable<Bytes10>, IFixedBytes<Bytes10>
{
    public const int BYTE_LENGTH = 10;

    public const int STRING_LENGTH = 22;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage10
    {
        private byte _element0;
    }

    private ByteStorage10 _bytes;

    public static Bytes10 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes10>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes10 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes10 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 10-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes10 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes10 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes10 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes10 requires exactly 10 bytes", nameof(bytes));
        }

        var result = default(Bytes10);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes10 other)
        => ((
            (LoadU64Raw(0) ^ other.LoadU64Raw(0))
            | ((ulong) (LoadU8Raw(8) ^ other.LoadU8Raw(8)))
            | ((ulong) (LoadU8Raw(9) ^ other.LoadU8Raw(9)))
        )) == 0;

    public bool Equals(Bytes10 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes10 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU64BE(0));
        hash.Add(LoadU8Raw(8));
        hash.Add(LoadU8Raw(9));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes10 other)
    {
        int cmp0 = LoadU64BE(0).CompareTo(other.LoadU64BE(0));
        if(cmp0 != 0)
        {
            return cmp0;
        }

        int byteCmp8 = LoadU8Raw(8).CompareTo(other.LoadU8Raw(8));
        if(byteCmp8 != 0)
        {
            return byteCmp8;
        }

        int byteCmp9 = LoadU8Raw(9).CompareTo(other.LoadU8Raw(9));
        if(byteCmp9 != 0)
        {
            return byteCmp9;
        }

        return 0;
    }

    public int CompareTo(Bytes10 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes10 left, in Bytes10 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes10 left, in Bytes10 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes11 : IEquatable<Bytes11>, IComparable<Bytes11>, IFixedBytes<Bytes11>
{
    public const int BYTE_LENGTH = 11;

    public const int STRING_LENGTH = 24;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage11
    {
        private byte _element0;
    }

    private ByteStorage11 _bytes;

    public static Bytes11 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes11>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes11 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes11 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 11-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes11 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes11 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes11 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes11 requires exactly 11 bytes", nameof(bytes));
        }

        var result = default(Bytes11);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes11 other)
        => ((
            (LoadU64Raw(0) ^ other.LoadU64Raw(0))
            | ((ulong) (LoadU8Raw(8) ^ other.LoadU8Raw(8)))
            | ((ulong) (LoadU8Raw(9) ^ other.LoadU8Raw(9)))
            | ((ulong) (LoadU8Raw(10) ^ other.LoadU8Raw(10)))
        )) == 0;

    public bool Equals(Bytes11 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes11 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU64BE(0));
        hash.Add(LoadU8Raw(8));
        hash.Add(LoadU8Raw(9));
        hash.Add(LoadU8Raw(10));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes11 other)
    {
        int cmp0 = LoadU64BE(0).CompareTo(other.LoadU64BE(0));
        if(cmp0 != 0)
        {
            return cmp0;
        }

        int byteCmp8 = LoadU8Raw(8).CompareTo(other.LoadU8Raw(8));
        if(byteCmp8 != 0)
        {
            return byteCmp8;
        }

        int byteCmp9 = LoadU8Raw(9).CompareTo(other.LoadU8Raw(9));
        if(byteCmp9 != 0)
        {
            return byteCmp9;
        }

        int byteCmp10 = LoadU8Raw(10).CompareTo(other.LoadU8Raw(10));
        if(byteCmp10 != 0)
        {
            return byteCmp10;
        }

        return 0;
    }

    public int CompareTo(Bytes11 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes11 left, in Bytes11 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes11 left, in Bytes11 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes12 : IEquatable<Bytes12>, IComparable<Bytes12>, IFixedBytes<Bytes12>
{
    public const int BYTE_LENGTH = 12;

    public const int STRING_LENGTH = 26;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage12
    {
        private byte _element0;
    }

    private ByteStorage12 _bytes;

    public static Bytes12 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes12>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes12 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes12 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 12-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes12 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes12 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes12 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes12 requires exactly 12 bytes", nameof(bytes));
        }

        var result = default(Bytes12);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes12 other)
        => ((
            (LoadU64Raw(0) ^ other.LoadU64Raw(0))
            | ((ulong) (LoadU8Raw(8) ^ other.LoadU8Raw(8)))
            | ((ulong) (LoadU8Raw(9) ^ other.LoadU8Raw(9)))
            | ((ulong) (LoadU8Raw(10) ^ other.LoadU8Raw(10)))
            | ((ulong) (LoadU8Raw(11) ^ other.LoadU8Raw(11)))
        )) == 0;

    public bool Equals(Bytes12 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes12 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU64BE(0));
        hash.Add(LoadU8Raw(8));
        hash.Add(LoadU8Raw(9));
        hash.Add(LoadU8Raw(10));
        hash.Add(LoadU8Raw(11));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes12 other)
    {
        int cmp0 = LoadU64BE(0).CompareTo(other.LoadU64BE(0));
        if(cmp0 != 0)
        {
            return cmp0;
        }

        int byteCmp8 = LoadU8Raw(8).CompareTo(other.LoadU8Raw(8));
        if(byteCmp8 != 0)
        {
            return byteCmp8;
        }

        int byteCmp9 = LoadU8Raw(9).CompareTo(other.LoadU8Raw(9));
        if(byteCmp9 != 0)
        {
            return byteCmp9;
        }

        int byteCmp10 = LoadU8Raw(10).CompareTo(other.LoadU8Raw(10));
        if(byteCmp10 != 0)
        {
            return byteCmp10;
        }

        int byteCmp11 = LoadU8Raw(11).CompareTo(other.LoadU8Raw(11));
        if(byteCmp11 != 0)
        {
            return byteCmp11;
        }

        return 0;
    }

    public int CompareTo(Bytes12 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes12 left, in Bytes12 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes12 left, in Bytes12 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes13 : IEquatable<Bytes13>, IComparable<Bytes13>, IFixedBytes<Bytes13>
{
    public const int BYTE_LENGTH = 13;

    public const int STRING_LENGTH = 28;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage13
    {
        private byte _element0;
    }

    private ByteStorage13 _bytes;

    public static Bytes13 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes13>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes13 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes13 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 13-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes13 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes13 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes13 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes13 requires exactly 13 bytes", nameof(bytes));
        }

        var result = default(Bytes13);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes13 other)
        => ((
            (LoadU64Raw(0) ^ other.LoadU64Raw(0))
            | ((ulong) (LoadU8Raw(8) ^ other.LoadU8Raw(8)))
            | ((ulong) (LoadU8Raw(9) ^ other.LoadU8Raw(9)))
            | ((ulong) (LoadU8Raw(10) ^ other.LoadU8Raw(10)))
            | ((ulong) (LoadU8Raw(11) ^ other.LoadU8Raw(11)))
            | ((ulong) (LoadU8Raw(12) ^ other.LoadU8Raw(12)))
        )) == 0;

    public bool Equals(Bytes13 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes13 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU64BE(0));
        hash.Add(LoadU8Raw(8));
        hash.Add(LoadU8Raw(9));
        hash.Add(LoadU8Raw(10));
        hash.Add(LoadU8Raw(11));
        hash.Add(LoadU8Raw(12));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes13 other)
    {
        int cmp0 = LoadU64BE(0).CompareTo(other.LoadU64BE(0));
        if(cmp0 != 0)
        {
            return cmp0;
        }

        int byteCmp8 = LoadU8Raw(8).CompareTo(other.LoadU8Raw(8));
        if(byteCmp8 != 0)
        {
            return byteCmp8;
        }

        int byteCmp9 = LoadU8Raw(9).CompareTo(other.LoadU8Raw(9));
        if(byteCmp9 != 0)
        {
            return byteCmp9;
        }

        int byteCmp10 = LoadU8Raw(10).CompareTo(other.LoadU8Raw(10));
        if(byteCmp10 != 0)
        {
            return byteCmp10;
        }

        int byteCmp11 = LoadU8Raw(11).CompareTo(other.LoadU8Raw(11));
        if(byteCmp11 != 0)
        {
            return byteCmp11;
        }

        int byteCmp12 = LoadU8Raw(12).CompareTo(other.LoadU8Raw(12));
        if(byteCmp12 != 0)
        {
            return byteCmp12;
        }

        return 0;
    }

    public int CompareTo(Bytes13 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes13 left, in Bytes13 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes13 left, in Bytes13 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes14 : IEquatable<Bytes14>, IComparable<Bytes14>, IFixedBytes<Bytes14>
{
    public const int BYTE_LENGTH = 14;

    public const int STRING_LENGTH = 30;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage14
    {
        private byte _element0;
    }

    private ByteStorage14 _bytes;

    public static Bytes14 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes14>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes14 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes14 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 14-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes14 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes14 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes14 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes14 requires exactly 14 bytes", nameof(bytes));
        }

        var result = default(Bytes14);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes14 other)
        => ((
            (LoadU64Raw(0) ^ other.LoadU64Raw(0))
            | ((ulong) (LoadU8Raw(8) ^ other.LoadU8Raw(8)))
            | ((ulong) (LoadU8Raw(9) ^ other.LoadU8Raw(9)))
            | ((ulong) (LoadU8Raw(10) ^ other.LoadU8Raw(10)))
            | ((ulong) (LoadU8Raw(11) ^ other.LoadU8Raw(11)))
            | ((ulong) (LoadU8Raw(12) ^ other.LoadU8Raw(12)))
            | ((ulong) (LoadU8Raw(13) ^ other.LoadU8Raw(13)))
        )) == 0;

    public bool Equals(Bytes14 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes14 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU64BE(0));
        hash.Add(LoadU8Raw(8));
        hash.Add(LoadU8Raw(9));
        hash.Add(LoadU8Raw(10));
        hash.Add(LoadU8Raw(11));
        hash.Add(LoadU8Raw(12));
        hash.Add(LoadU8Raw(13));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes14 other)
    {
        int cmp0 = LoadU64BE(0).CompareTo(other.LoadU64BE(0));
        if(cmp0 != 0)
        {
            return cmp0;
        }

        int byteCmp8 = LoadU8Raw(8).CompareTo(other.LoadU8Raw(8));
        if(byteCmp8 != 0)
        {
            return byteCmp8;
        }

        int byteCmp9 = LoadU8Raw(9).CompareTo(other.LoadU8Raw(9));
        if(byteCmp9 != 0)
        {
            return byteCmp9;
        }

        int byteCmp10 = LoadU8Raw(10).CompareTo(other.LoadU8Raw(10));
        if(byteCmp10 != 0)
        {
            return byteCmp10;
        }

        int byteCmp11 = LoadU8Raw(11).CompareTo(other.LoadU8Raw(11));
        if(byteCmp11 != 0)
        {
            return byteCmp11;
        }

        int byteCmp12 = LoadU8Raw(12).CompareTo(other.LoadU8Raw(12));
        if(byteCmp12 != 0)
        {
            return byteCmp12;
        }

        int byteCmp13 = LoadU8Raw(13).CompareTo(other.LoadU8Raw(13));
        if(byteCmp13 != 0)
        {
            return byteCmp13;
        }

        return 0;
    }

    public int CompareTo(Bytes14 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes14 left, in Bytes14 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes14 left, in Bytes14 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes15 : IEquatable<Bytes15>, IComparable<Bytes15>, IFixedBytes<Bytes15>
{
    public const int BYTE_LENGTH = 15;

    public const int STRING_LENGTH = 32;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage15
    {
        private byte _element0;
    }

    private ByteStorage15 _bytes;

    public static Bytes15 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes15>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes15 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes15 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 15-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes15 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes15 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes15 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes15 requires exactly 15 bytes", nameof(bytes));
        }

        var result = default(Bytes15);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes15 other)
        => ((
            (LoadU64Raw(0) ^ other.LoadU64Raw(0))
            | ((ulong) (LoadU8Raw(8) ^ other.LoadU8Raw(8)))
            | ((ulong) (LoadU8Raw(9) ^ other.LoadU8Raw(9)))
            | ((ulong) (LoadU8Raw(10) ^ other.LoadU8Raw(10)))
            | ((ulong) (LoadU8Raw(11) ^ other.LoadU8Raw(11)))
            | ((ulong) (LoadU8Raw(12) ^ other.LoadU8Raw(12)))
            | ((ulong) (LoadU8Raw(13) ^ other.LoadU8Raw(13)))
            | ((ulong) (LoadU8Raw(14) ^ other.LoadU8Raw(14)))
        )) == 0;

    public bool Equals(Bytes15 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes15 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU64BE(0));
        hash.Add(LoadU8Raw(8));
        hash.Add(LoadU8Raw(9));
        hash.Add(LoadU8Raw(10));
        hash.Add(LoadU8Raw(11));
        hash.Add(LoadU8Raw(12));
        hash.Add(LoadU8Raw(13));
        hash.Add(LoadU8Raw(14));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes15 other)
    {
        int cmp0 = LoadU64BE(0).CompareTo(other.LoadU64BE(0));
        if(cmp0 != 0)
        {
            return cmp0;
        }

        int byteCmp8 = LoadU8Raw(8).CompareTo(other.LoadU8Raw(8));
        if(byteCmp8 != 0)
        {
            return byteCmp8;
        }

        int byteCmp9 = LoadU8Raw(9).CompareTo(other.LoadU8Raw(9));
        if(byteCmp9 != 0)
        {
            return byteCmp9;
        }

        int byteCmp10 = LoadU8Raw(10).CompareTo(other.LoadU8Raw(10));
        if(byteCmp10 != 0)
        {
            return byteCmp10;
        }

        int byteCmp11 = LoadU8Raw(11).CompareTo(other.LoadU8Raw(11));
        if(byteCmp11 != 0)
        {
            return byteCmp11;
        }

        int byteCmp12 = LoadU8Raw(12).CompareTo(other.LoadU8Raw(12));
        if(byteCmp12 != 0)
        {
            return byteCmp12;
        }

        int byteCmp13 = LoadU8Raw(13).CompareTo(other.LoadU8Raw(13));
        if(byteCmp13 != 0)
        {
            return byteCmp13;
        }

        int byteCmp14 = LoadU8Raw(14).CompareTo(other.LoadU8Raw(14));
        if(byteCmp14 != 0)
        {
            return byteCmp14;
        }

        return 0;
    }

    public int CompareTo(Bytes15 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes15 left, in Bytes15 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes15 left, in Bytes15 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes16 : IEquatable<Bytes16>, IComparable<Bytes16>, IFixedBytes<Bytes16>
{
    public const int BYTE_LENGTH = 16;

    public const int STRING_LENGTH = 34;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage16
    {
        private byte _element0;
    }

    private ByteStorage16 _bytes;

    public static Bytes16 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes16>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes16 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes16 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 16-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes16 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes16 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes16 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes16 requires exactly 16 bytes", nameof(bytes));
        }

        var result = default(Bytes16);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes16 other)
        => ((
            (LoadU64Raw(0) ^ other.LoadU64Raw(0))
            | (LoadU64Raw(8) ^ other.LoadU64Raw(8))
        )) == 0;

    public bool Equals(Bytes16 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes16 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU64BE(0));
        hash.Add(LoadU64BE(8));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes16 other)
    {
        int cmp0 = LoadU64BE(0).CompareTo(other.LoadU64BE(0));
        if(cmp0 != 0)
        {
            return cmp0;
        }

        int cmp8 = LoadU64BE(8).CompareTo(other.LoadU64BE(8));
        if(cmp8 != 0)
        {
            return cmp8;
        }

        return 0;
    }

    public int CompareTo(Bytes16 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes16 left, in Bytes16 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes16 left, in Bytes16 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes17 : IEquatable<Bytes17>, IComparable<Bytes17>, IFixedBytes<Bytes17>
{
    public const int BYTE_LENGTH = 17;

    public const int STRING_LENGTH = 36;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage17
    {
        private byte _element0;
    }

    private ByteStorage17 _bytes;

    public static Bytes17 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes17>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes17 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes17 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 17-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes17 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes17 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes17 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes17 requires exactly 17 bytes", nameof(bytes));
        }

        var result = default(Bytes17);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes17 other)
        => ((
            (LoadU64Raw(0) ^ other.LoadU64Raw(0))
            | (LoadU64Raw(8) ^ other.LoadU64Raw(8))
            | ((ulong) (LoadU8Raw(16) ^ other.LoadU8Raw(16)))
        )) == 0;

    public bool Equals(Bytes17 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes17 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU64BE(0));
        hash.Add(LoadU64BE(8));
        hash.Add(LoadU8Raw(16));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes17 other)
    {
        int cmp0 = LoadU64BE(0).CompareTo(other.LoadU64BE(0));
        if(cmp0 != 0)
        {
            return cmp0;
        }

        int cmp8 = LoadU64BE(8).CompareTo(other.LoadU64BE(8));
        if(cmp8 != 0)
        {
            return cmp8;
        }

        int byteCmp16 = LoadU8Raw(16).CompareTo(other.LoadU8Raw(16));
        if(byteCmp16 != 0)
        {
            return byteCmp16;
        }

        return 0;
    }

    public int CompareTo(Bytes17 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes17 left, in Bytes17 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes17 left, in Bytes17 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes18 : IEquatable<Bytes18>, IComparable<Bytes18>, IFixedBytes<Bytes18>
{
    public const int BYTE_LENGTH = 18;

    public const int STRING_LENGTH = 38;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage18
    {
        private byte _element0;
    }

    private ByteStorage18 _bytes;

    public static Bytes18 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes18>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes18 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes18 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 18-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes18 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes18 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes18 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes18 requires exactly 18 bytes", nameof(bytes));
        }

        var result = default(Bytes18);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes18 other)
        => ((
            (LoadU64Raw(0) ^ other.LoadU64Raw(0))
            | (LoadU64Raw(8) ^ other.LoadU64Raw(8))
            | ((ulong) (LoadU8Raw(16) ^ other.LoadU8Raw(16)))
            | ((ulong) (LoadU8Raw(17) ^ other.LoadU8Raw(17)))
        )) == 0;

    public bool Equals(Bytes18 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes18 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU64BE(0));
        hash.Add(LoadU64BE(8));
        hash.Add(LoadU8Raw(16));
        hash.Add(LoadU8Raw(17));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes18 other)
    {
        int cmp0 = LoadU64BE(0).CompareTo(other.LoadU64BE(0));
        if(cmp0 != 0)
        {
            return cmp0;
        }

        int cmp8 = LoadU64BE(8).CompareTo(other.LoadU64BE(8));
        if(cmp8 != 0)
        {
            return cmp8;
        }

        int byteCmp16 = LoadU8Raw(16).CompareTo(other.LoadU8Raw(16));
        if(byteCmp16 != 0)
        {
            return byteCmp16;
        }

        int byteCmp17 = LoadU8Raw(17).CompareTo(other.LoadU8Raw(17));
        if(byteCmp17 != 0)
        {
            return byteCmp17;
        }

        return 0;
    }

    public int CompareTo(Bytes18 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes18 left, in Bytes18 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes18 left, in Bytes18 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes19 : IEquatable<Bytes19>, IComparable<Bytes19>, IFixedBytes<Bytes19>
{
    public const int BYTE_LENGTH = 19;

    public const int STRING_LENGTH = 40;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage19
    {
        private byte _element0;
    }

    private ByteStorage19 _bytes;

    public static Bytes19 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes19>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes19 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes19 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 19-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes19 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes19 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes19 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes19 requires exactly 19 bytes", nameof(bytes));
        }

        var result = default(Bytes19);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes19 other)
        => ((
            (LoadU64Raw(0) ^ other.LoadU64Raw(0))
            | (LoadU64Raw(8) ^ other.LoadU64Raw(8))
            | ((ulong) (LoadU8Raw(16) ^ other.LoadU8Raw(16)))
            | ((ulong) (LoadU8Raw(17) ^ other.LoadU8Raw(17)))
            | ((ulong) (LoadU8Raw(18) ^ other.LoadU8Raw(18)))
        )) == 0;

    public bool Equals(Bytes19 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes19 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU64BE(0));
        hash.Add(LoadU64BE(8));
        hash.Add(LoadU8Raw(16));
        hash.Add(LoadU8Raw(17));
        hash.Add(LoadU8Raw(18));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes19 other)
    {
        int cmp0 = LoadU64BE(0).CompareTo(other.LoadU64BE(0));
        if(cmp0 != 0)
        {
            return cmp0;
        }

        int cmp8 = LoadU64BE(8).CompareTo(other.LoadU64BE(8));
        if(cmp8 != 0)
        {
            return cmp8;
        }

        int byteCmp16 = LoadU8Raw(16).CompareTo(other.LoadU8Raw(16));
        if(byteCmp16 != 0)
        {
            return byteCmp16;
        }

        int byteCmp17 = LoadU8Raw(17).CompareTo(other.LoadU8Raw(17));
        if(byteCmp17 != 0)
        {
            return byteCmp17;
        }

        int byteCmp18 = LoadU8Raw(18).CompareTo(other.LoadU8Raw(18));
        if(byteCmp18 != 0)
        {
            return byteCmp18;
        }

        return 0;
    }

    public int CompareTo(Bytes19 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes19 left, in Bytes19 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes19 left, in Bytes19 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes20 : IEquatable<Bytes20>, IComparable<Bytes20>, IFixedBytes<Bytes20>
{
    public const int BYTE_LENGTH = 20;

    public const int STRING_LENGTH = 42;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage20
    {
        private byte _element0;
    }

    private ByteStorage20 _bytes;

    public static Bytes20 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes20>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes20 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes20 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 20-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes20 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes20 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes20 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes20 requires exactly 20 bytes", nameof(bytes));
        }

        var result = default(Bytes20);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes20 other)
        => ((
            (LoadU64Raw(0) ^ other.LoadU64Raw(0))
            | (LoadU64Raw(8) ^ other.LoadU64Raw(8))
            | ((ulong) (LoadU8Raw(16) ^ other.LoadU8Raw(16)))
            | ((ulong) (LoadU8Raw(17) ^ other.LoadU8Raw(17)))
            | ((ulong) (LoadU8Raw(18) ^ other.LoadU8Raw(18)))
            | ((ulong) (LoadU8Raw(19) ^ other.LoadU8Raw(19)))
        )) == 0;

    public bool Equals(Bytes20 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes20 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU64BE(0));
        hash.Add(LoadU64BE(8));
        hash.Add(LoadU8Raw(16));
        hash.Add(LoadU8Raw(17));
        hash.Add(LoadU8Raw(18));
        hash.Add(LoadU8Raw(19));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes20 other)
    {
        int cmp0 = LoadU64BE(0).CompareTo(other.LoadU64BE(0));
        if(cmp0 != 0)
        {
            return cmp0;
        }

        int cmp8 = LoadU64BE(8).CompareTo(other.LoadU64BE(8));
        if(cmp8 != 0)
        {
            return cmp8;
        }

        int byteCmp16 = LoadU8Raw(16).CompareTo(other.LoadU8Raw(16));
        if(byteCmp16 != 0)
        {
            return byteCmp16;
        }

        int byteCmp17 = LoadU8Raw(17).CompareTo(other.LoadU8Raw(17));
        if(byteCmp17 != 0)
        {
            return byteCmp17;
        }

        int byteCmp18 = LoadU8Raw(18).CompareTo(other.LoadU8Raw(18));
        if(byteCmp18 != 0)
        {
            return byteCmp18;
        }

        int byteCmp19 = LoadU8Raw(19).CompareTo(other.LoadU8Raw(19));
        if(byteCmp19 != 0)
        {
            return byteCmp19;
        }

        return 0;
    }

    public int CompareTo(Bytes20 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes20 left, in Bytes20 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes20 left, in Bytes20 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes21 : IEquatable<Bytes21>, IComparable<Bytes21>, IFixedBytes<Bytes21>
{
    public const int BYTE_LENGTH = 21;

    public const int STRING_LENGTH = 44;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage21
    {
        private byte _element0;
    }

    private ByteStorage21 _bytes;

    public static Bytes21 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes21>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes21 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes21 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 21-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes21 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes21 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes21 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes21 requires exactly 21 bytes", nameof(bytes));
        }

        var result = default(Bytes21);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes21 other)
        => ((
            (LoadU64Raw(0) ^ other.LoadU64Raw(0))
            | (LoadU64Raw(8) ^ other.LoadU64Raw(8))
            | ((ulong) (LoadU8Raw(16) ^ other.LoadU8Raw(16)))
            | ((ulong) (LoadU8Raw(17) ^ other.LoadU8Raw(17)))
            | ((ulong) (LoadU8Raw(18) ^ other.LoadU8Raw(18)))
            | ((ulong) (LoadU8Raw(19) ^ other.LoadU8Raw(19)))
            | ((ulong) (LoadU8Raw(20) ^ other.LoadU8Raw(20)))
        )) == 0;

    public bool Equals(Bytes21 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes21 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU64BE(0));
        hash.Add(LoadU64BE(8));
        hash.Add(LoadU8Raw(16));
        hash.Add(LoadU8Raw(17));
        hash.Add(LoadU8Raw(18));
        hash.Add(LoadU8Raw(19));
        hash.Add(LoadU8Raw(20));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes21 other)
    {
        int cmp0 = LoadU64BE(0).CompareTo(other.LoadU64BE(0));
        if(cmp0 != 0)
        {
            return cmp0;
        }

        int cmp8 = LoadU64BE(8).CompareTo(other.LoadU64BE(8));
        if(cmp8 != 0)
        {
            return cmp8;
        }

        int byteCmp16 = LoadU8Raw(16).CompareTo(other.LoadU8Raw(16));
        if(byteCmp16 != 0)
        {
            return byteCmp16;
        }

        int byteCmp17 = LoadU8Raw(17).CompareTo(other.LoadU8Raw(17));
        if(byteCmp17 != 0)
        {
            return byteCmp17;
        }

        int byteCmp18 = LoadU8Raw(18).CompareTo(other.LoadU8Raw(18));
        if(byteCmp18 != 0)
        {
            return byteCmp18;
        }

        int byteCmp19 = LoadU8Raw(19).CompareTo(other.LoadU8Raw(19));
        if(byteCmp19 != 0)
        {
            return byteCmp19;
        }

        int byteCmp20 = LoadU8Raw(20).CompareTo(other.LoadU8Raw(20));
        if(byteCmp20 != 0)
        {
            return byteCmp20;
        }

        return 0;
    }

    public int CompareTo(Bytes21 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes21 left, in Bytes21 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes21 left, in Bytes21 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes22 : IEquatable<Bytes22>, IComparable<Bytes22>, IFixedBytes<Bytes22>
{
    public const int BYTE_LENGTH = 22;

    public const int STRING_LENGTH = 46;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage22
    {
        private byte _element0;
    }

    private ByteStorage22 _bytes;

    public static Bytes22 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes22>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes22 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes22 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 22-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes22 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes22 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes22 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes22 requires exactly 22 bytes", nameof(bytes));
        }

        var result = default(Bytes22);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes22 other)
        => ((
            (LoadU64Raw(0) ^ other.LoadU64Raw(0))
            | (LoadU64Raw(8) ^ other.LoadU64Raw(8))
            | ((ulong) (LoadU8Raw(16) ^ other.LoadU8Raw(16)))
            | ((ulong) (LoadU8Raw(17) ^ other.LoadU8Raw(17)))
            | ((ulong) (LoadU8Raw(18) ^ other.LoadU8Raw(18)))
            | ((ulong) (LoadU8Raw(19) ^ other.LoadU8Raw(19)))
            | ((ulong) (LoadU8Raw(20) ^ other.LoadU8Raw(20)))
            | ((ulong) (LoadU8Raw(21) ^ other.LoadU8Raw(21)))
        )) == 0;

    public bool Equals(Bytes22 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes22 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU64BE(0));
        hash.Add(LoadU64BE(8));
        hash.Add(LoadU8Raw(16));
        hash.Add(LoadU8Raw(17));
        hash.Add(LoadU8Raw(18));
        hash.Add(LoadU8Raw(19));
        hash.Add(LoadU8Raw(20));
        hash.Add(LoadU8Raw(21));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes22 other)
    {
        int cmp0 = LoadU64BE(0).CompareTo(other.LoadU64BE(0));
        if(cmp0 != 0)
        {
            return cmp0;
        }

        int cmp8 = LoadU64BE(8).CompareTo(other.LoadU64BE(8));
        if(cmp8 != 0)
        {
            return cmp8;
        }

        int byteCmp16 = LoadU8Raw(16).CompareTo(other.LoadU8Raw(16));
        if(byteCmp16 != 0)
        {
            return byteCmp16;
        }

        int byteCmp17 = LoadU8Raw(17).CompareTo(other.LoadU8Raw(17));
        if(byteCmp17 != 0)
        {
            return byteCmp17;
        }

        int byteCmp18 = LoadU8Raw(18).CompareTo(other.LoadU8Raw(18));
        if(byteCmp18 != 0)
        {
            return byteCmp18;
        }

        int byteCmp19 = LoadU8Raw(19).CompareTo(other.LoadU8Raw(19));
        if(byteCmp19 != 0)
        {
            return byteCmp19;
        }

        int byteCmp20 = LoadU8Raw(20).CompareTo(other.LoadU8Raw(20));
        if(byteCmp20 != 0)
        {
            return byteCmp20;
        }

        int byteCmp21 = LoadU8Raw(21).CompareTo(other.LoadU8Raw(21));
        if(byteCmp21 != 0)
        {
            return byteCmp21;
        }

        return 0;
    }

    public int CompareTo(Bytes22 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes22 left, in Bytes22 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes22 left, in Bytes22 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes23 : IEquatable<Bytes23>, IComparable<Bytes23>, IFixedBytes<Bytes23>
{
    public const int BYTE_LENGTH = 23;

    public const int STRING_LENGTH = 48;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage23
    {
        private byte _element0;
    }

    private ByteStorage23 _bytes;

    public static Bytes23 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes23>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes23 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes23 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 23-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes23 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes23 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes23 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes23 requires exactly 23 bytes", nameof(bytes));
        }

        var result = default(Bytes23);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes23 other)
        => ((
            (LoadU64Raw(0) ^ other.LoadU64Raw(0))
            | (LoadU64Raw(8) ^ other.LoadU64Raw(8))
            | ((ulong) (LoadU8Raw(16) ^ other.LoadU8Raw(16)))
            | ((ulong) (LoadU8Raw(17) ^ other.LoadU8Raw(17)))
            | ((ulong) (LoadU8Raw(18) ^ other.LoadU8Raw(18)))
            | ((ulong) (LoadU8Raw(19) ^ other.LoadU8Raw(19)))
            | ((ulong) (LoadU8Raw(20) ^ other.LoadU8Raw(20)))
            | ((ulong) (LoadU8Raw(21) ^ other.LoadU8Raw(21)))
            | ((ulong) (LoadU8Raw(22) ^ other.LoadU8Raw(22)))
        )) == 0;

    public bool Equals(Bytes23 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes23 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU64BE(0));
        hash.Add(LoadU64BE(8));
        hash.Add(LoadU8Raw(16));
        hash.Add(LoadU8Raw(17));
        hash.Add(LoadU8Raw(18));
        hash.Add(LoadU8Raw(19));
        hash.Add(LoadU8Raw(20));
        hash.Add(LoadU8Raw(21));
        hash.Add(LoadU8Raw(22));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes23 other)
    {
        int cmp0 = LoadU64BE(0).CompareTo(other.LoadU64BE(0));
        if(cmp0 != 0)
        {
            return cmp0;
        }

        int cmp8 = LoadU64BE(8).CompareTo(other.LoadU64BE(8));
        if(cmp8 != 0)
        {
            return cmp8;
        }

        int byteCmp16 = LoadU8Raw(16).CompareTo(other.LoadU8Raw(16));
        if(byteCmp16 != 0)
        {
            return byteCmp16;
        }

        int byteCmp17 = LoadU8Raw(17).CompareTo(other.LoadU8Raw(17));
        if(byteCmp17 != 0)
        {
            return byteCmp17;
        }

        int byteCmp18 = LoadU8Raw(18).CompareTo(other.LoadU8Raw(18));
        if(byteCmp18 != 0)
        {
            return byteCmp18;
        }

        int byteCmp19 = LoadU8Raw(19).CompareTo(other.LoadU8Raw(19));
        if(byteCmp19 != 0)
        {
            return byteCmp19;
        }

        int byteCmp20 = LoadU8Raw(20).CompareTo(other.LoadU8Raw(20));
        if(byteCmp20 != 0)
        {
            return byteCmp20;
        }

        int byteCmp21 = LoadU8Raw(21).CompareTo(other.LoadU8Raw(21));
        if(byteCmp21 != 0)
        {
            return byteCmp21;
        }

        int byteCmp22 = LoadU8Raw(22).CompareTo(other.LoadU8Raw(22));
        if(byteCmp22 != 0)
        {
            return byteCmp22;
        }

        return 0;
    }

    public int CompareTo(Bytes23 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes23 left, in Bytes23 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes23 left, in Bytes23 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes24 : IEquatable<Bytes24>, IComparable<Bytes24>, IFixedBytes<Bytes24>
{
    public const int BYTE_LENGTH = 24;

    public const int STRING_LENGTH = 50;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage24
    {
        private byte _element0;
    }

    private ByteStorage24 _bytes;

    public static Bytes24 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes24>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes24 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes24 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 24-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes24 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes24 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes24 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes24 requires exactly 24 bytes", nameof(bytes));
        }

        var result = default(Bytes24);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes24 other)
        => ((
            (LoadU64Raw(0) ^ other.LoadU64Raw(0))
            | (LoadU64Raw(8) ^ other.LoadU64Raw(8))
            | (LoadU64Raw(16) ^ other.LoadU64Raw(16))
        )) == 0;

    public bool Equals(Bytes24 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes24 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU64BE(0));
        hash.Add(LoadU64BE(8));
        hash.Add(LoadU64BE(16));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes24 other)
    {
        int cmp0 = LoadU64BE(0).CompareTo(other.LoadU64BE(0));
        if(cmp0 != 0)
        {
            return cmp0;
        }

        int cmp8 = LoadU64BE(8).CompareTo(other.LoadU64BE(8));
        if(cmp8 != 0)
        {
            return cmp8;
        }

        int cmp16 = LoadU64BE(16).CompareTo(other.LoadU64BE(16));
        if(cmp16 != 0)
        {
            return cmp16;
        }

        return 0;
    }

    public int CompareTo(Bytes24 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes24 left, in Bytes24 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes24 left, in Bytes24 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes25 : IEquatable<Bytes25>, IComparable<Bytes25>, IFixedBytes<Bytes25>
{
    public const int BYTE_LENGTH = 25;

    public const int STRING_LENGTH = 52;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage25
    {
        private byte _element0;
    }

    private ByteStorage25 _bytes;

    public static Bytes25 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes25>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes25 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes25 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 25-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes25 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes25 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes25 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes25 requires exactly 25 bytes", nameof(bytes));
        }

        var result = default(Bytes25);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes25 other)
        => ((
            (LoadU64Raw(0) ^ other.LoadU64Raw(0))
            | (LoadU64Raw(8) ^ other.LoadU64Raw(8))
            | (LoadU64Raw(16) ^ other.LoadU64Raw(16))
            | ((ulong) (LoadU8Raw(24) ^ other.LoadU8Raw(24)))
        )) == 0;

    public bool Equals(Bytes25 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes25 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU64BE(0));
        hash.Add(LoadU64BE(8));
        hash.Add(LoadU64BE(16));
        hash.Add(LoadU8Raw(24));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes25 other)
    {
        int cmp0 = LoadU64BE(0).CompareTo(other.LoadU64BE(0));
        if(cmp0 != 0)
        {
            return cmp0;
        }

        int cmp8 = LoadU64BE(8).CompareTo(other.LoadU64BE(8));
        if(cmp8 != 0)
        {
            return cmp8;
        }

        int cmp16 = LoadU64BE(16).CompareTo(other.LoadU64BE(16));
        if(cmp16 != 0)
        {
            return cmp16;
        }

        int byteCmp24 = LoadU8Raw(24).CompareTo(other.LoadU8Raw(24));
        if(byteCmp24 != 0)
        {
            return byteCmp24;
        }

        return 0;
    }

    public int CompareTo(Bytes25 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes25 left, in Bytes25 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes25 left, in Bytes25 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes26 : IEquatable<Bytes26>, IComparable<Bytes26>, IFixedBytes<Bytes26>
{
    public const int BYTE_LENGTH = 26;

    public const int STRING_LENGTH = 54;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage26
    {
        private byte _element0;
    }

    private ByteStorage26 _bytes;

    public static Bytes26 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes26>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes26 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes26 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 26-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes26 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes26 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes26 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes26 requires exactly 26 bytes", nameof(bytes));
        }

        var result = default(Bytes26);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes26 other)
        => ((
            (LoadU64Raw(0) ^ other.LoadU64Raw(0))
            | (LoadU64Raw(8) ^ other.LoadU64Raw(8))
            | (LoadU64Raw(16) ^ other.LoadU64Raw(16))
            | ((ulong) (LoadU8Raw(24) ^ other.LoadU8Raw(24)))
            | ((ulong) (LoadU8Raw(25) ^ other.LoadU8Raw(25)))
        )) == 0;

    public bool Equals(Bytes26 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes26 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU64BE(0));
        hash.Add(LoadU64BE(8));
        hash.Add(LoadU64BE(16));
        hash.Add(LoadU8Raw(24));
        hash.Add(LoadU8Raw(25));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes26 other)
    {
        int cmp0 = LoadU64BE(0).CompareTo(other.LoadU64BE(0));
        if(cmp0 != 0)
        {
            return cmp0;
        }

        int cmp8 = LoadU64BE(8).CompareTo(other.LoadU64BE(8));
        if(cmp8 != 0)
        {
            return cmp8;
        }

        int cmp16 = LoadU64BE(16).CompareTo(other.LoadU64BE(16));
        if(cmp16 != 0)
        {
            return cmp16;
        }

        int byteCmp24 = LoadU8Raw(24).CompareTo(other.LoadU8Raw(24));
        if(byteCmp24 != 0)
        {
            return byteCmp24;
        }

        int byteCmp25 = LoadU8Raw(25).CompareTo(other.LoadU8Raw(25));
        if(byteCmp25 != 0)
        {
            return byteCmp25;
        }

        return 0;
    }

    public int CompareTo(Bytes26 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes26 left, in Bytes26 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes26 left, in Bytes26 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes27 : IEquatable<Bytes27>, IComparable<Bytes27>, IFixedBytes<Bytes27>
{
    public const int BYTE_LENGTH = 27;

    public const int STRING_LENGTH = 56;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage27
    {
        private byte _element0;
    }

    private ByteStorage27 _bytes;

    public static Bytes27 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes27>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes27 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes27 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 27-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes27 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes27 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes27 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes27 requires exactly 27 bytes", nameof(bytes));
        }

        var result = default(Bytes27);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes27 other)
        => ((
            (LoadU64Raw(0) ^ other.LoadU64Raw(0))
            | (LoadU64Raw(8) ^ other.LoadU64Raw(8))
            | (LoadU64Raw(16) ^ other.LoadU64Raw(16))
            | ((ulong) (LoadU8Raw(24) ^ other.LoadU8Raw(24)))
            | ((ulong) (LoadU8Raw(25) ^ other.LoadU8Raw(25)))
            | ((ulong) (LoadU8Raw(26) ^ other.LoadU8Raw(26)))
        )) == 0;

    public bool Equals(Bytes27 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes27 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU64BE(0));
        hash.Add(LoadU64BE(8));
        hash.Add(LoadU64BE(16));
        hash.Add(LoadU8Raw(24));
        hash.Add(LoadU8Raw(25));
        hash.Add(LoadU8Raw(26));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes27 other)
    {
        int cmp0 = LoadU64BE(0).CompareTo(other.LoadU64BE(0));
        if(cmp0 != 0)
        {
            return cmp0;
        }

        int cmp8 = LoadU64BE(8).CompareTo(other.LoadU64BE(8));
        if(cmp8 != 0)
        {
            return cmp8;
        }

        int cmp16 = LoadU64BE(16).CompareTo(other.LoadU64BE(16));
        if(cmp16 != 0)
        {
            return cmp16;
        }

        int byteCmp24 = LoadU8Raw(24).CompareTo(other.LoadU8Raw(24));
        if(byteCmp24 != 0)
        {
            return byteCmp24;
        }

        int byteCmp25 = LoadU8Raw(25).CompareTo(other.LoadU8Raw(25));
        if(byteCmp25 != 0)
        {
            return byteCmp25;
        }

        int byteCmp26 = LoadU8Raw(26).CompareTo(other.LoadU8Raw(26));
        if(byteCmp26 != 0)
        {
            return byteCmp26;
        }

        return 0;
    }

    public int CompareTo(Bytes27 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes27 left, in Bytes27 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes27 left, in Bytes27 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes28 : IEquatable<Bytes28>, IComparable<Bytes28>, IFixedBytes<Bytes28>
{
    public const int BYTE_LENGTH = 28;

    public const int STRING_LENGTH = 58;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage28
    {
        private byte _element0;
    }

    private ByteStorage28 _bytes;

    public static Bytes28 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes28>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes28 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes28 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 28-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes28 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes28 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes28 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes28 requires exactly 28 bytes", nameof(bytes));
        }

        var result = default(Bytes28);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes28 other)
        => ((
            (LoadU64Raw(0) ^ other.LoadU64Raw(0))
            | (LoadU64Raw(8) ^ other.LoadU64Raw(8))
            | (LoadU64Raw(16) ^ other.LoadU64Raw(16))
            | ((ulong) (LoadU8Raw(24) ^ other.LoadU8Raw(24)))
            | ((ulong) (LoadU8Raw(25) ^ other.LoadU8Raw(25)))
            | ((ulong) (LoadU8Raw(26) ^ other.LoadU8Raw(26)))
            | ((ulong) (LoadU8Raw(27) ^ other.LoadU8Raw(27)))
        )) == 0;

    public bool Equals(Bytes28 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes28 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU64BE(0));
        hash.Add(LoadU64BE(8));
        hash.Add(LoadU64BE(16));
        hash.Add(LoadU8Raw(24));
        hash.Add(LoadU8Raw(25));
        hash.Add(LoadU8Raw(26));
        hash.Add(LoadU8Raw(27));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes28 other)
    {
        int cmp0 = LoadU64BE(0).CompareTo(other.LoadU64BE(0));
        if(cmp0 != 0)
        {
            return cmp0;
        }

        int cmp8 = LoadU64BE(8).CompareTo(other.LoadU64BE(8));
        if(cmp8 != 0)
        {
            return cmp8;
        }

        int cmp16 = LoadU64BE(16).CompareTo(other.LoadU64BE(16));
        if(cmp16 != 0)
        {
            return cmp16;
        }

        int byteCmp24 = LoadU8Raw(24).CompareTo(other.LoadU8Raw(24));
        if(byteCmp24 != 0)
        {
            return byteCmp24;
        }

        int byteCmp25 = LoadU8Raw(25).CompareTo(other.LoadU8Raw(25));
        if(byteCmp25 != 0)
        {
            return byteCmp25;
        }

        int byteCmp26 = LoadU8Raw(26).CompareTo(other.LoadU8Raw(26));
        if(byteCmp26 != 0)
        {
            return byteCmp26;
        }

        int byteCmp27 = LoadU8Raw(27).CompareTo(other.LoadU8Raw(27));
        if(byteCmp27 != 0)
        {
            return byteCmp27;
        }

        return 0;
    }

    public int CompareTo(Bytes28 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes28 left, in Bytes28 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes28 left, in Bytes28 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes29 : IEquatable<Bytes29>, IComparable<Bytes29>, IFixedBytes<Bytes29>
{
    public const int BYTE_LENGTH = 29;

    public const int STRING_LENGTH = 60;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage29
    {
        private byte _element0;
    }

    private ByteStorage29 _bytes;

    public static Bytes29 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes29>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes29 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes29 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 29-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes29 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes29 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes29 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes29 requires exactly 29 bytes", nameof(bytes));
        }

        var result = default(Bytes29);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes29 other)
        => ((
            (LoadU64Raw(0) ^ other.LoadU64Raw(0))
            | (LoadU64Raw(8) ^ other.LoadU64Raw(8))
            | (LoadU64Raw(16) ^ other.LoadU64Raw(16))
            | ((ulong) (LoadU8Raw(24) ^ other.LoadU8Raw(24)))
            | ((ulong) (LoadU8Raw(25) ^ other.LoadU8Raw(25)))
            | ((ulong) (LoadU8Raw(26) ^ other.LoadU8Raw(26)))
            | ((ulong) (LoadU8Raw(27) ^ other.LoadU8Raw(27)))
            | ((ulong) (LoadU8Raw(28) ^ other.LoadU8Raw(28)))
        )) == 0;

    public bool Equals(Bytes29 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes29 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU64BE(0));
        hash.Add(LoadU64BE(8));
        hash.Add(LoadU64BE(16));
        hash.Add(LoadU8Raw(24));
        hash.Add(LoadU8Raw(25));
        hash.Add(LoadU8Raw(26));
        hash.Add(LoadU8Raw(27));
        hash.Add(LoadU8Raw(28));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes29 other)
    {
        int cmp0 = LoadU64BE(0).CompareTo(other.LoadU64BE(0));
        if(cmp0 != 0)
        {
            return cmp0;
        }

        int cmp8 = LoadU64BE(8).CompareTo(other.LoadU64BE(8));
        if(cmp8 != 0)
        {
            return cmp8;
        }

        int cmp16 = LoadU64BE(16).CompareTo(other.LoadU64BE(16));
        if(cmp16 != 0)
        {
            return cmp16;
        }

        int byteCmp24 = LoadU8Raw(24).CompareTo(other.LoadU8Raw(24));
        if(byteCmp24 != 0)
        {
            return byteCmp24;
        }

        int byteCmp25 = LoadU8Raw(25).CompareTo(other.LoadU8Raw(25));
        if(byteCmp25 != 0)
        {
            return byteCmp25;
        }

        int byteCmp26 = LoadU8Raw(26).CompareTo(other.LoadU8Raw(26));
        if(byteCmp26 != 0)
        {
            return byteCmp26;
        }

        int byteCmp27 = LoadU8Raw(27).CompareTo(other.LoadU8Raw(27));
        if(byteCmp27 != 0)
        {
            return byteCmp27;
        }

        int byteCmp28 = LoadU8Raw(28).CompareTo(other.LoadU8Raw(28));
        if(byteCmp28 != 0)
        {
            return byteCmp28;
        }

        return 0;
    }

    public int CompareTo(Bytes29 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes29 left, in Bytes29 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes29 left, in Bytes29 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes30 : IEquatable<Bytes30>, IComparable<Bytes30>, IFixedBytes<Bytes30>
{
    public const int BYTE_LENGTH = 30;

    public const int STRING_LENGTH = 62;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage30
    {
        private byte _element0;
    }

    private ByteStorage30 _bytes;

    public static Bytes30 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes30>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes30 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes30 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 30-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes30 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes30 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes30 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes30 requires exactly 30 bytes", nameof(bytes));
        }

        var result = default(Bytes30);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes30 other)
        => ((
            (LoadU64Raw(0) ^ other.LoadU64Raw(0))
            | (LoadU64Raw(8) ^ other.LoadU64Raw(8))
            | (LoadU64Raw(16) ^ other.LoadU64Raw(16))
            | ((ulong) (LoadU8Raw(24) ^ other.LoadU8Raw(24)))
            | ((ulong) (LoadU8Raw(25) ^ other.LoadU8Raw(25)))
            | ((ulong) (LoadU8Raw(26) ^ other.LoadU8Raw(26)))
            | ((ulong) (LoadU8Raw(27) ^ other.LoadU8Raw(27)))
            | ((ulong) (LoadU8Raw(28) ^ other.LoadU8Raw(28)))
            | ((ulong) (LoadU8Raw(29) ^ other.LoadU8Raw(29)))
        )) == 0;

    public bool Equals(Bytes30 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes30 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU64BE(0));
        hash.Add(LoadU64BE(8));
        hash.Add(LoadU64BE(16));
        hash.Add(LoadU8Raw(24));
        hash.Add(LoadU8Raw(25));
        hash.Add(LoadU8Raw(26));
        hash.Add(LoadU8Raw(27));
        hash.Add(LoadU8Raw(28));
        hash.Add(LoadU8Raw(29));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes30 other)
    {
        int cmp0 = LoadU64BE(0).CompareTo(other.LoadU64BE(0));
        if(cmp0 != 0)
        {
            return cmp0;
        }

        int cmp8 = LoadU64BE(8).CompareTo(other.LoadU64BE(8));
        if(cmp8 != 0)
        {
            return cmp8;
        }

        int cmp16 = LoadU64BE(16).CompareTo(other.LoadU64BE(16));
        if(cmp16 != 0)
        {
            return cmp16;
        }

        int byteCmp24 = LoadU8Raw(24).CompareTo(other.LoadU8Raw(24));
        if(byteCmp24 != 0)
        {
            return byteCmp24;
        }

        int byteCmp25 = LoadU8Raw(25).CompareTo(other.LoadU8Raw(25));
        if(byteCmp25 != 0)
        {
            return byteCmp25;
        }

        int byteCmp26 = LoadU8Raw(26).CompareTo(other.LoadU8Raw(26));
        if(byteCmp26 != 0)
        {
            return byteCmp26;
        }

        int byteCmp27 = LoadU8Raw(27).CompareTo(other.LoadU8Raw(27));
        if(byteCmp27 != 0)
        {
            return byteCmp27;
        }

        int byteCmp28 = LoadU8Raw(28).CompareTo(other.LoadU8Raw(28));
        if(byteCmp28 != 0)
        {
            return byteCmp28;
        }

        int byteCmp29 = LoadU8Raw(29).CompareTo(other.LoadU8Raw(29));
        if(byteCmp29 != 0)
        {
            return byteCmp29;
        }

        return 0;
    }

    public int CompareTo(Bytes30 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes30 left, in Bytes30 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes30 left, in Bytes30 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

public struct Bytes31 : IEquatable<Bytes31>, IComparable<Bytes31>, IFixedBytes<Bytes31>
{
    public const int BYTE_LENGTH = 31;

    public const int STRING_LENGTH = 64;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage31
    {
        private byte _element0;
    }

    private ByteStorage31 _bytes;

    public static Bytes31 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes31>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes31 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes31 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 31-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes31 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes31 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes31 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes31 requires exactly 31 bytes", nameof(bytes));
        }

        var result = default(Bytes31);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes31 other)
        => ((
            (LoadU64Raw(0) ^ other.LoadU64Raw(0))
            | (LoadU64Raw(8) ^ other.LoadU64Raw(8))
            | (LoadU64Raw(16) ^ other.LoadU64Raw(16))
            | ((ulong) (LoadU8Raw(24) ^ other.LoadU8Raw(24)))
            | ((ulong) (LoadU8Raw(25) ^ other.LoadU8Raw(25)))
            | ((ulong) (LoadU8Raw(26) ^ other.LoadU8Raw(26)))
            | ((ulong) (LoadU8Raw(27) ^ other.LoadU8Raw(27)))
            | ((ulong) (LoadU8Raw(28) ^ other.LoadU8Raw(28)))
            | ((ulong) (LoadU8Raw(29) ^ other.LoadU8Raw(29)))
            | ((ulong) (LoadU8Raw(30) ^ other.LoadU8Raw(30)))
        )) == 0;

    public bool Equals(Bytes31 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes31 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU64BE(0));
        hash.Add(LoadU64BE(8));
        hash.Add(LoadU64BE(16));
        hash.Add(LoadU8Raw(24));
        hash.Add(LoadU8Raw(25));
        hash.Add(LoadU8Raw(26));
        hash.Add(LoadU8Raw(27));
        hash.Add(LoadU8Raw(28));
        hash.Add(LoadU8Raw(29));
        hash.Add(LoadU8Raw(30));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes31 other)
    {
        int cmp0 = LoadU64BE(0).CompareTo(other.LoadU64BE(0));
        if(cmp0 != 0)
        {
            return cmp0;
        }

        int cmp8 = LoadU64BE(8).CompareTo(other.LoadU64BE(8));
        if(cmp8 != 0)
        {
            return cmp8;
        }

        int cmp16 = LoadU64BE(16).CompareTo(other.LoadU64BE(16));
        if(cmp16 != 0)
        {
            return cmp16;
        }

        int byteCmp24 = LoadU8Raw(24).CompareTo(other.LoadU8Raw(24));
        if(byteCmp24 != 0)
        {
            return byteCmp24;
        }

        int byteCmp25 = LoadU8Raw(25).CompareTo(other.LoadU8Raw(25));
        if(byteCmp25 != 0)
        {
            return byteCmp25;
        }

        int byteCmp26 = LoadU8Raw(26).CompareTo(other.LoadU8Raw(26));
        if(byteCmp26 != 0)
        {
            return byteCmp26;
        }

        int byteCmp27 = LoadU8Raw(27).CompareTo(other.LoadU8Raw(27));
        if(byteCmp27 != 0)
        {
            return byteCmp27;
        }

        int byteCmp28 = LoadU8Raw(28).CompareTo(other.LoadU8Raw(28));
        if(byteCmp28 != 0)
        {
            return byteCmp28;
        }

        int byteCmp29 = LoadU8Raw(29).CompareTo(other.LoadU8Raw(29));
        if(byteCmp29 != 0)
        {
            return byteCmp29;
        }

        int byteCmp30 = LoadU8Raw(30).CompareTo(other.LoadU8Raw(30));
        if(byteCmp30 != 0)
        {
            return byteCmp30;
        }

        return 0;
    }

    public int CompareTo(Bytes31 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes31 left, in Bytes31 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes31 left, in Bytes31 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}

[JsonConverter(typeof(Bytes32Converter))]
public struct Bytes32 : IEquatable<Bytes32>, IComparable<Bytes32>, IFixedBytes<Bytes32>
{
    public const int BYTE_LENGTH = 32;

    public const int STRING_LENGTH = 66;

    [InlineArray(BYTE_LENGTH)]
    private struct ByteStorage32
    {
        private byte _element0;
    }

    private ByteStorage32 _bytes;

    public static Bytes32 Zero => default;

    public ReadOnlySpan<byte> Bytes
        => MemoryMarshal.CreateReadOnlySpan(ref _bytes[0], BYTE_LENGTH);

    static int IFixedBytes<Bytes32>.BYTE_LENGTH => BYTE_LENGTH;

    public static Bytes32 Parse(string value)
        => Parse(value.AsSpan());

    public static Bytes32 Parse(ReadOnlySpan<char> value)
        => !TryParse(value, out var parsed)
            ? throw new FormatException("Expected a 32-byte value with optional 0x prefix.")
            : parsed;

    public static bool TryParse(string? value, out Bytes32 parsed)
    {
        if(value is null)
        {
            parsed = default;
            return false;
        }

        return TryParse(value.AsSpan(), out parsed);
    }

    public static bool TryParse(ReadOnlySpan<char> value, out Bytes32 parsed)
    {
        parsed = default;
        var span = value;

        if(span.Length == STRING_LENGTH)
        {
            if(span[0] != '0' || (span[1] != 'x' && span[1] != 'X'))
            {
                return false;
            }

            span = span[2..];
        }
        else if(span.Length != BYTE_LENGTH * 2)
        {
            return false;
        }

        Span<byte> bytes = stackalloc byte[BYTE_LENGTH];
        var status = Convert.FromHexString(span, bytes, out int charsConsumed, out int bytesWritten);
        if(status != OperationStatus.Done
            || charsConsumed != BYTE_LENGTH * 2
            || bytesWritten != BYTE_LENGTH)
        {
            return false;
        }

        bytes.CopyTo(MemoryMarshal.CreateSpan(ref parsed._bytes[0], BYTE_LENGTH));
        return true;
    }

    public static Bytes32 FromBytes(ReadOnlySpan<byte> bytes)
    {
        if(bytes.Length != BYTE_LENGTH)
        {
            throw new ArgumentException("Bytes32 requires exactly 32 bytes", nameof(bytes));
        }

        var result = default(Bytes32);
        bytes.CopyTo(MemoryMarshal.CreateSpan(ref result._bytes[0], BYTE_LENGTH));
        return result;
    }

    public byte[] ToArray()
    {
        byte[] copy = new byte[BYTE_LENGTH];
        Bytes.CopyTo(copy);
        return copy;
    }

    public override string ToString()
        => HexUtils.ToPrefixedHexString(Bytes);

    [OverloadResolutionPriority(1)]
    public bool Equals(in Bytes32 other)
        => ((
            (LoadU64Raw(0) ^ other.LoadU64Raw(0))
            | (LoadU64Raw(8) ^ other.LoadU64Raw(8))
            | (LoadU64Raw(16) ^ other.LoadU64Raw(16))
            | (LoadU64Raw(24) ^ other.LoadU64Raw(24))
        )) == 0;

    public bool Equals(Bytes32 other)
        => Equals(in other);

    public override bool Equals(object? obj)
        => obj is Bytes32 other && Equals(other);

    public override int GetHashCode()
    {
        var hash = new HashCode();
        hash.Add(LoadU64BE(0));
        hash.Add(LoadU64BE(8));
        hash.Add(LoadU64BE(16));
        hash.Add(LoadU64BE(24));
        return hash.ToHashCode();
    }

    [OverloadResolutionPriority(1)]
    public int CompareTo(in Bytes32 other)
    {
        int cmp0 = LoadU64BE(0).CompareTo(other.LoadU64BE(0));
        if(cmp0 != 0)
        {
            return cmp0;
        }

        int cmp8 = LoadU64BE(8).CompareTo(other.LoadU64BE(8));
        if(cmp8 != 0)
        {
            return cmp8;
        }

        int cmp16 = LoadU64BE(16).CompareTo(other.LoadU64BE(16));
        if(cmp16 != 0)
        {
            return cmp16;
        }

        int cmp24 = LoadU64BE(24).CompareTo(other.LoadU64BE(24));
        if(cmp24 != 0)
        {
            return cmp24;
        }

        return 0;
    }

    public int CompareTo(Bytes32 other)
        => CompareTo(in other);

    public static bool operator ==(in Bytes32 left, in Bytes32 right)
        => left.Equals(in right);

    public static bool operator !=(in Bytes32 left, in Bytes32 right)
        => !left.Equals(in right);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64Raw(int offset)
        => Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref _bytes[0], offset));

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private byte LoadU8Raw(int offset)
        => Unsafe.Add(ref _bytes[0], offset);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ulong LoadU64BE(int offset)
    {
        ulong value = LoadU64Raw(offset);
        return BitConverter.IsLittleEndian
            ? BinaryPrimitives.ReverseEndianness(value)
            : value;
    }
}
#pragma warning restore CS1591, CS0675
